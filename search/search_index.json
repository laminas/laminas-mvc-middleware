{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"laminas-mvc-middleware This library provides the ability to dispatch middleware pipelines in place of controllers within laminas-mvc. Installation Run the following to install this library: $ composer require laminas/laminas-mvc-middleware Documentation Browse the documentation online at https://docs.laminas.dev/laminas-mvc-middleware/ Support Issues Chat Forum","title":"Home"},{"location":"#laminas-mvc-middleware","text":"This library provides the ability to dispatch middleware pipelines in place of controllers within laminas-mvc.","title":"laminas-mvc-middleware"},{"location":"#installation","text":"Run the following to install this library: $ composer require laminas/laminas-mvc-middleware","title":"Installation"},{"location":"#documentation","text":"Browse the documentation online at https://docs.laminas.dev/laminas-mvc-middleware/","title":"Documentation"},{"location":"#support","text":"Issues Chat Forum","title":"Support"},{"location":"intro/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/laminas-mvc-middleware/v2/intro/'; });","title":"_intro"},{"location":"v1/intro/","text":"Introduction This library provides the ability to dispatch middleware pipelines in place of controllers within laminas-mvc. Dispatching PSR-7 Middleware PSR-7 defines interfaces for HTTP messages, and is now being adopted by many frameworks; Laminas itself offers a parallel microframework targeting PSR-7 with Mezzio . What if you want to dispatch PSR-7 middleware from laminas-mvc ? laminas-mvc currently uses laminas-http for its HTTP transport layer, and the objects it defines are not compatible with PSR-7, meaning the basic MVC layer does not and cannot make use of PSR-7 currently. However, starting with version 2.7.0, laminas-mvc offers Laminas\\Mvc\\MiddlewareListener . This Laminas\\Mvc\\MvcEvent::EVENT_DISPATCH listener listens prior to the default DispatchListener , and executes if the route matches contain a \"middleware\" parameter, and the service that resolves to is callable. When those conditions are met, it uses the PSR-7 bridge to convert the laminas-http request and response objects into PSR-7 instances, and then invokes the middleware. Starting with laminas-mvc version 3.2.0, Laminas\\Mvc\\MiddlewareListener is deprecated and replaced by Laminas\\Mvc\\Middleware\\MiddlewareListener provided by this package. After package installation, Laminas\\Mvc\\Middleware module must be registered in your laminas-mvc based application. Mapping Routes to Middleware The first step is to map a route to PSR-7 middleware. This looks like any other routing configuration, with one small change: instead of providing a controller in the routing defaults, you provide middleware : // Via configuration: use Application\\Middleware\\IndexMiddleware; use Laminas\\Router\\Http\\Literal; return [ 'router' =&gt; [ 'routes' =&gt; [ 'home' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/', 'defaults' =&gt; [ 'middleware' =&gt; IndexMiddleware::class, ], ], ], ], ], ]; Middleware may be provided as PHP callables, http-interop/http-middleware or as string service names. You may also specify an array of above middleware types. These will then be piped into a Laminas\\Stratigility\\MiddlewarePipe instance in the order in which they are present in the array. Starting with the 1.1 release, direct usage of double-pass and callable middleware is deprecated. laminas-stratigility 2.2 provides the following decorators and helper functions that are forwards-compatible with its 3.0 release: Laminas\\Stratigility\\Middleware\\CallableMiddlewareDecorator Laminas\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator Laminas\\Stratigility\\doublePassMiddleware() Laminas\\Stratigility\\middleware() No Action Required Unlike action controllers, middleware typically is single purpose, and, as such, does not require a default action parameter. Middleware Services In a normal laminas-mvc dispatch cycle, controllers are pulled from a dedicated ControllerManager . Middleware, however, are pulled from the application service manager. Middleware retrieved must be PHP callables or http-middleware instances. The MiddlewareListener will create an error response if non-callable middleware is indicated. Writing Middleware Starting in laminas-mvc 3.1.0 and continued in this package, the MiddlewareListener always adds middleware to a Laminas\\Stratigility\\MiddlewarePipe instance, and invokes it as http-interop/http-middleware , passing it a PSR-7 ServerRequestInterface and an http-interop DelegateInterface . As such, ideally your middleware should implement the MiddlewareInterface from http-interop/http-middleware : namespace Application\\Middleware; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; class IndexMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // do some work } } Alternately, you may still write callable middleware using the following signature: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; function (ServerRequestInterface $request, ResponseInterface $response, callable $next) { // do some work } In the above case, the DelegateInterface is decorated as a callable. In all versions, within your middleware, you can pull information from the composed request, and return a response. Routing Parameters Route match parameters are pushed into the PSR-7 ServerRequest as attributes, and may thus be fetched using $request-&gt;getAttribute($attributeName) . Middleware Return Values Your middleware must return a PSR-7 response. It is converted back to a laminas-http response and returned by the MiddlewareListener , causing the application to short-circuit and return the response immediately.","title":"Introduction"},{"location":"v1/intro/#introduction","text":"This library provides the ability to dispatch middleware pipelines in place of controllers within laminas-mvc.","title":"Introduction"},{"location":"v1/intro/#dispatching-psr-7-middleware","text":"PSR-7 defines interfaces for HTTP messages, and is now being adopted by many frameworks; Laminas itself offers a parallel microframework targeting PSR-7 with Mezzio . What if you want to dispatch PSR-7 middleware from laminas-mvc ? laminas-mvc currently uses laminas-http for its HTTP transport layer, and the objects it defines are not compatible with PSR-7, meaning the basic MVC layer does not and cannot make use of PSR-7 currently. However, starting with version 2.7.0, laminas-mvc offers Laminas\\Mvc\\MiddlewareListener . This Laminas\\Mvc\\MvcEvent::EVENT_DISPATCH listener listens prior to the default DispatchListener , and executes if the route matches contain a \"middleware\" parameter, and the service that resolves to is callable. When those conditions are met, it uses the PSR-7 bridge to convert the laminas-http request and response objects into PSR-7 instances, and then invokes the middleware. Starting with laminas-mvc version 3.2.0, Laminas\\Mvc\\MiddlewareListener is deprecated and replaced by Laminas\\Mvc\\Middleware\\MiddlewareListener provided by this package. After package installation, Laminas\\Mvc\\Middleware module must be registered in your laminas-mvc based application.","title":"Dispatching PSR-7 Middleware"},{"location":"v1/intro/#mapping-routes-to-middleware","text":"The first step is to map a route to PSR-7 middleware. This looks like any other routing configuration, with one small change: instead of providing a controller in the routing defaults, you provide middleware : // Via configuration: use Application\\Middleware\\IndexMiddleware; use Laminas\\Router\\Http\\Literal; return [ 'router' =&gt; [ 'routes' =&gt; [ 'home' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/', 'defaults' =&gt; [ 'middleware' =&gt; IndexMiddleware::class, ], ], ], ], ], ]; Middleware may be provided as PHP callables, http-interop/http-middleware or as string service names. You may also specify an array of above middleware types. These will then be piped into a Laminas\\Stratigility\\MiddlewarePipe instance in the order in which they are present in the array. Starting with the 1.1 release, direct usage of double-pass and callable middleware is deprecated. laminas-stratigility 2.2 provides the following decorators and helper functions that are forwards-compatible with its 3.0 release: Laminas\\Stratigility\\Middleware\\CallableMiddlewareDecorator Laminas\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator Laminas\\Stratigility\\doublePassMiddleware() Laminas\\Stratigility\\middleware()","title":"Mapping Routes to Middleware"},{"location":"v1/intro/#middleware-services","text":"In a normal laminas-mvc dispatch cycle, controllers are pulled from a dedicated ControllerManager . Middleware, however, are pulled from the application service manager. Middleware retrieved must be PHP callables or http-middleware instances. The MiddlewareListener will create an error response if non-callable middleware is indicated.","title":"Middleware Services"},{"location":"v1/intro/#writing-middleware","text":"Starting in laminas-mvc 3.1.0 and continued in this package, the MiddlewareListener always adds middleware to a Laminas\\Stratigility\\MiddlewarePipe instance, and invokes it as http-interop/http-middleware , passing it a PSR-7 ServerRequestInterface and an http-interop DelegateInterface . As such, ideally your middleware should implement the MiddlewareInterface from http-interop/http-middleware : namespace Application\\Middleware; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; class IndexMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // do some work } } Alternately, you may still write callable middleware using the following signature: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; function (ServerRequestInterface $request, ResponseInterface $response, callable $next) { // do some work } In the above case, the DelegateInterface is decorated as a callable. In all versions, within your middleware, you can pull information from the composed request, and return a response.","title":"Writing Middleware"},{"location":"v1/intro/#middleware-return-values","text":"Your middleware must return a PSR-7 response. It is converted back to a laminas-http response and returned by the MiddlewareListener , causing the application to short-circuit and return the response immediately.","title":"Middleware Return Values"},{"location":"v2/dispatching-middleware/","text":"Dispatching Middleware Apart from PSR-15 Psr\\Http\\Server\\MiddlewareInterface or Psr\\Http\\Server\\RequestHandlerInterface middleware or service name strings which resolve to such instances, the middleware key in the route definition takes also an instance of the PipeSpec class for the middleware pipe comprising the former. Technically, middleware or middleware pipe defined in each individual mvc route is a complete request handler: it must produce a response and cannot delegate to a controller or middleware defined in another route. Here are some examples how middleware can be dispatched: MiddlewareInterface or RequestHandlerInterface Service Strings If you only dispatch one class, the preferred method is passing a container service class-string or alias which resolves to a PSR-15 Psr\\Http\\Server\\MiddlewareInterface or Psr\\Http\\Server\\RequestHandlerInterface . Laminas\\Stratigility\\MiddlewarePipe implements both interfaces and could be provided by the application container as a configured instance. It is what is used internally for the PipeSpec definitions. use Application\\Handler\\AlbumDetailHandler; use Application\\Middleware\\AlbumDetailMiddlewarePipe; use Laminas\\Mvc\\Middleware\\PipeSpec; use Laminas\\Router\\Http\\Literal; return [ 'router' =&gt; [ 'routes' =&gt; [ 'container-handler-class-literal' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/container-handler-class-literal', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; AlbumDetailHandler::class, ], ], ], 'container-handler' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/container-handler', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; 'container_id_for_album_detail_handler', ], ], ], 'container-pipe' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/container-pipe', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; AlbumDetailMiddlewarePipe::class, ], ], ], 'container-middleware' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/container-middleware', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; SomeMiddleware::class, ], ], ], ], ], ]; PipeSpec with PSR-15 Service Names Middleware can be passed as a PipeSpec object with container service class-string literals. This is the preferred method, if you need to dispatch multiple middleware instances. Assuming you have two middleware, Application\\Middleware\\SelectLanguageMiddleware which determines the language of the visitor and Application\\Middleware\\AlbumFromRouteMiddleware which fetches an Album object by the ID in the route param. Both of them add this information to the ServerRequestInterface attributes which can be used by the Application\\Handler\\AlbumDetailHandler at the end of the pipe: use Application\\Handler\\AlbumDetailHandler; use Application\\Middleware\\AlbumFromRouteMiddlware; use Application\\Middleware\\SelectLanguageMiddleware; use Laminas\\Mvc\\Middleware\\PipeSpec; use Laminas\\Router\\Http\\Segment; return [ 'router' =&gt; [ 'routes' =&gt; [ 'album-details' =&gt; [ 'type' =&gt; Segment::class, 'options' =&gt; [ 'route' =&gt; '/album/:album_id', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; new PipeSpec( SelectLanguageMiddleware::class, AlbumFromRouteMiddelware::class, AlbumDetailHandler::class ), ], ], ], ], ], ]; Anonymous Interface Implementations You can also pass an anonymous class which implements MiddlewareInterface or RequestHandlerInterface directly. This is intended primarily for development because it can cause issues with configuration caching. use Laminas\\Diactoros\\Response\\TextResponse; use Laminas\\Mvc\\Middleware\\PipeSpec; use Laminas\\Router\\Http\\Literal; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; return [ 'router' =&gt; [ 'routes' =&gt; [ 'instance-middleware' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/instance-middleware', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; new class implements MiddlewareInterface { public function process( ServerRequestInterface $request, RequestHandlerInterface $handler ): ResponseInterface { // You have to return a response directly because attempting to use $handler here will // always result in an empty pipeline exception. // This middleware pipe does not delegate to controllers or middleware from other routes. return new TextResponse('Hello!'); } }, ], ], ], 'instance-handler' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/instance-handler', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; new class implements RequestHandlerInterface { public function handle( ServerRequestInterface $request ): ResponseInterface { return new TextResponse('Hello!'); } }, ], ], ], ], ], ]; Closures A Closure can also be passed directly. This should also be used only for development. use Laminas\\Mvc\\Middleware\\PipeSpec; use Laminas\\Router\\Http\\Literal; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; return [ 'router' =&gt; [ 'routes' =&gt; [ 'closure' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/closure', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; static function ( ServerRequestInterface $request, RequestHandlerInterface $handler ): ResponseInterface { return $handler-&gt;handle($request); }, ], ], ], ], ], ]; Mixed PipeSpec Arguments In this example multiple different possible parameters are passed to PipeSpec : use Application\\Handler\\AlbumDetailHandler; use Laminas\\Mvc\\Middleware\\PipeSpec; use Laminas\\Router\\Http\\Literal; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; return [ 'router' =&gt; [ 'routes' =&gt; [ 'instance-pipespec-dev-env' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/instance-pipespec-dev-env', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; new PipeSpec( // id/alias of service in container 'container_id_for_album_middleware', // anonymous class implementing a MiddlewareInterface new class implements MiddlewareInterface { public function process( ServerRequestInterface $request, RequestHandlerInterface $handler ): ResponseInterface { return $handler-&gt;handle($request); } }, // Closure static function ( ServerRequestInterface $request, RequestHandlerInterface $handler ): ResponseInterface { return $handler-&gt;handle($request); }, // class-string of a handler as a convenient way to specify id/alias // which must be resolved by the container AlbumDetailHandler::class, ), ], ], ], ], ], ]; Note Please note that if you pass instances of middleware or handlers directly, it might not be compatible with config caching. You should use that for development only. The recommended variant is passing container managed middleware like SomeRequestHandler::class . Defining :middleware Placeholder in Route Definition Although you can define a :middleware placeholder in your middleware route definition, we are strongly advising against doing so. This can be utilized maliciously to invoke middleware that was never intended to be called directly. Since middleware lookup uses the main application container, it can also be abused to cause instantiation of expensive services leading to a DoS vulnerability.","title":"Dispatching Middleware"},{"location":"v2/dispatching-middleware/#dispatching-middleware","text":"Apart from PSR-15 Psr\\Http\\Server\\MiddlewareInterface or Psr\\Http\\Server\\RequestHandlerInterface middleware or service name strings which resolve to such instances, the middleware key in the route definition takes also an instance of the PipeSpec class for the middleware pipe comprising the former. Technically, middleware or middleware pipe defined in each individual mvc route is a complete request handler: it must produce a response and cannot delegate to a controller or middleware defined in another route. Here are some examples how middleware can be dispatched:","title":"Dispatching Middleware"},{"location":"v2/dispatching-middleware/#middlewareinterface-or-requesthandlerinterface-service-strings","text":"If you only dispatch one class, the preferred method is passing a container service class-string or alias which resolves to a PSR-15 Psr\\Http\\Server\\MiddlewareInterface or Psr\\Http\\Server\\RequestHandlerInterface . Laminas\\Stratigility\\MiddlewarePipe implements both interfaces and could be provided by the application container as a configured instance. It is what is used internally for the PipeSpec definitions. use Application\\Handler\\AlbumDetailHandler; use Application\\Middleware\\AlbumDetailMiddlewarePipe; use Laminas\\Mvc\\Middleware\\PipeSpec; use Laminas\\Router\\Http\\Literal; return [ 'router' =&gt; [ 'routes' =&gt; [ 'container-handler-class-literal' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/container-handler-class-literal', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; AlbumDetailHandler::class, ], ], ], 'container-handler' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/container-handler', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; 'container_id_for_album_detail_handler', ], ], ], 'container-pipe' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/container-pipe', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; AlbumDetailMiddlewarePipe::class, ], ], ], 'container-middleware' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/container-middleware', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; SomeMiddleware::class, ], ], ], ], ], ];","title":"MiddlewareInterface or RequestHandlerInterface Service Strings"},{"location":"v2/dispatching-middleware/#pipespec-with-psr-15-service-names","text":"Middleware can be passed as a PipeSpec object with container service class-string literals. This is the preferred method, if you need to dispatch multiple middleware instances. Assuming you have two middleware, Application\\Middleware\\SelectLanguageMiddleware which determines the language of the visitor and Application\\Middleware\\AlbumFromRouteMiddleware which fetches an Album object by the ID in the route param. Both of them add this information to the ServerRequestInterface attributes which can be used by the Application\\Handler\\AlbumDetailHandler at the end of the pipe: use Application\\Handler\\AlbumDetailHandler; use Application\\Middleware\\AlbumFromRouteMiddlware; use Application\\Middleware\\SelectLanguageMiddleware; use Laminas\\Mvc\\Middleware\\PipeSpec; use Laminas\\Router\\Http\\Segment; return [ 'router' =&gt; [ 'routes' =&gt; [ 'album-details' =&gt; [ 'type' =&gt; Segment::class, 'options' =&gt; [ 'route' =&gt; '/album/:album_id', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; new PipeSpec( SelectLanguageMiddleware::class, AlbumFromRouteMiddelware::class, AlbumDetailHandler::class ), ], ], ], ], ], ];","title":"PipeSpec with PSR-15 Service Names"},{"location":"v2/dispatching-middleware/#anonymous-interface-implementations","text":"You can also pass an anonymous class which implements MiddlewareInterface or RequestHandlerInterface directly. This is intended primarily for development because it can cause issues with configuration caching. use Laminas\\Diactoros\\Response\\TextResponse; use Laminas\\Mvc\\Middleware\\PipeSpec; use Laminas\\Router\\Http\\Literal; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; return [ 'router' =&gt; [ 'routes' =&gt; [ 'instance-middleware' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/instance-middleware', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; new class implements MiddlewareInterface { public function process( ServerRequestInterface $request, RequestHandlerInterface $handler ): ResponseInterface { // You have to return a response directly because attempting to use $handler here will // always result in an empty pipeline exception. // This middleware pipe does not delegate to controllers or middleware from other routes. return new TextResponse('Hello!'); } }, ], ], ], 'instance-handler' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/instance-handler', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; new class implements RequestHandlerInterface { public function handle( ServerRequestInterface $request ): ResponseInterface { return new TextResponse('Hello!'); } }, ], ], ], ], ], ];","title":"Anonymous Interface Implementations"},{"location":"v2/dispatching-middleware/#closures","text":"A Closure can also be passed directly. This should also be used only for development. use Laminas\\Mvc\\Middleware\\PipeSpec; use Laminas\\Router\\Http\\Literal; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; return [ 'router' =&gt; [ 'routes' =&gt; [ 'closure' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/closure', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; static function ( ServerRequestInterface $request, RequestHandlerInterface $handler ): ResponseInterface { return $handler-&gt;handle($request); }, ], ], ], ], ], ];","title":"Closures"},{"location":"v2/dispatching-middleware/#mixed-pipespec-arguments","text":"In this example multiple different possible parameters are passed to PipeSpec : use Application\\Handler\\AlbumDetailHandler; use Laminas\\Mvc\\Middleware\\PipeSpec; use Laminas\\Router\\Http\\Literal; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; return [ 'router' =&gt; [ 'routes' =&gt; [ 'instance-pipespec-dev-env' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/instance-pipespec-dev-env', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; new PipeSpec( // id/alias of service in container 'container_id_for_album_middleware', // anonymous class implementing a MiddlewareInterface new class implements MiddlewareInterface { public function process( ServerRequestInterface $request, RequestHandlerInterface $handler ): ResponseInterface { return $handler-&gt;handle($request); } }, // Closure static function ( ServerRequestInterface $request, RequestHandlerInterface $handler ): ResponseInterface { return $handler-&gt;handle($request); }, // class-string of a handler as a convenient way to specify id/alias // which must be resolved by the container AlbumDetailHandler::class, ), ], ], ], ], ], ];","title":"Mixed PipeSpec Arguments"},{"location":"v2/dispatching-middleware/#defining-middleware-placeholder-in-route-definition","text":"Although you can define a :middleware placeholder in your middleware route definition, we are strongly advising against doing so. This can be utilized maliciously to invoke middleware that was never intended to be called directly. Since middleware lookup uses the main application container, it can also be abused to cause instantiation of expensive services leading to a DoS vulnerability.","title":"Defining :middleware Placeholder in Route Definition"},{"location":"v2/installation/","text":"This is only a placeholder The content of this page can be found under: https://github.com/laminas/documentation-theme/blob/master/theme/pages/installation.html","title":"Installation"},{"location":"v2/installation/#this-is-only-a-placeholder","text":"The content of this page can be found under: https://github.com/laminas/documentation-theme/blob/master/theme/pages/installation.html","title":"This is only a placeholder"},{"location":"v2/intro/","text":"Introduction This library provides the ability to dispatch middleware pipelines in place of controllers within laminas-mvc . Dispatching PSR-15 Middleware and Request Handlers PSR-7 defines interfaces for HTTP messages, and is now being adopted by many frameworks. PSR-15 describes Middleware and Request Handler interfaces, which consume PSR-7 messages; Laminas itself offers a parallel microframework targeting PSR-7/PSR-15 with Mezzio . What if you want to dispatch PSR-15 middleware and request handlers from laminas-mvc? laminas-mvc currently uses laminas-http for its HTTP transport layer, and the objects it defines are not compatible with PSR-7, meaning the basic MVC layer does not and cannot make use of PSR-7 currently. However, starting with version 2.7.0, laminas-mvc offers Laminas\\Mvc\\MiddlewareListener . This Laminas\\Mvc\\MvcEvent::EVENT_DISPATCH listener listens prior to the default DispatchListener , and executes if the route matches contain a \"middleware\" parameter, and the service that resolves to is callable. When those conditions are met, it uses the PSR-7 bridge to convert the laminas-http request and response objects into PSR-7 instances, and then invokes the middleware. Starting with laminas-mvc version 3.2.0, Laminas\\Mvc\\MiddlewareListener is deprecated and replaced by Laminas\\Mvc\\Middleware\\MiddlewareListener provided by this package. After package installation, Laminas\\Mvc\\Middleware module must be registered in your laminas-mvc based application. If the laminas-component-installer is installed, it will handle the module registration automatically.","title":"Introduction"},{"location":"v2/intro/#introduction","text":"This library provides the ability to dispatch middleware pipelines in place of controllers within laminas-mvc .","title":"Introduction"},{"location":"v2/intro/#dispatching-psr-15-middleware-and-request-handlers","text":"PSR-7 defines interfaces for HTTP messages, and is now being adopted by many frameworks. PSR-15 describes Middleware and Request Handler interfaces, which consume PSR-7 messages; Laminas itself offers a parallel microframework targeting PSR-7/PSR-15 with Mezzio . What if you want to dispatch PSR-15 middleware and request handlers from laminas-mvc? laminas-mvc currently uses laminas-http for its HTTP transport layer, and the objects it defines are not compatible with PSR-7, meaning the basic MVC layer does not and cannot make use of PSR-7 currently. However, starting with version 2.7.0, laminas-mvc offers Laminas\\Mvc\\MiddlewareListener . This Laminas\\Mvc\\MvcEvent::EVENT_DISPATCH listener listens prior to the default DispatchListener , and executes if the route matches contain a \"middleware\" parameter, and the service that resolves to is callable. When those conditions are met, it uses the PSR-7 bridge to convert the laminas-http request and response objects into PSR-7 instances, and then invokes the middleware. Starting with laminas-mvc version 3.2.0, Laminas\\Mvc\\MiddlewareListener is deprecated and replaced by Laminas\\Mvc\\Middleware\\MiddlewareListener provided by this package. After package installation, Laminas\\Mvc\\Middleware module must be registered in your laminas-mvc based application. If the laminas-component-installer is installed, it will handle the module registration automatically.","title":"Dispatching PSR-15 Middleware and Request Handlers"},{"location":"v2/migration/","text":"Migration from Version 1 This document details changes made from version 1 of this package or from its implementation in laminas-mvc . If installed, it overrides the default behavior in laminas-mvc. 'controller' Route Array Key In addition to providing a 'middleware' array key in the route defaults definition, the value of the 'controller' array key has to be explicitly set to Laminas\\Mvc\\Middleware\\PipeSpec::class : /* ... */ 'some-route' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/some-route', 'defaults' =&gt; [ 'controller' =&gt; \\Laminas\\Mvc\\Middleware\\PipeSpec::class, 'middleware' =&gt; SomeRequestHandler::class, ], ], ], PipeSpec Instance in middleware Definition If you used to pass an array of middleware to the middleware array key to create a middleware pipe, it has to be rewritten to an instance of the PipeSpec object. Before: /* ... */ 'some-route' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/some-route', 'defaults' =&gt; [ 'middleware' =&gt; [ SomeMiddleware::class, SomeRequestHandler::class, ], ], ], ], After: /* ... */ 'some-route' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/some-route', 'defaults' =&gt; [ 'controller' =&gt; \\Laminas\\Mvc\\Middleware\\PipeSpec::class, 'middleware' =&gt; new \\Laminas\\Mvc\\Middleware\\PipeSpec( SomeMiddleware::class, SomeRequestHandler::class ), ], ], ], PSR-15 Middleware This package now supports only PSR-15 interfaces. Support of http-interop/http-middleware and callable middleware has been dropped. A Closure can still be used and its signature must match the signature of PSR-15 middleware: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; static function (ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface You have to rewrite all your existing handlers and middleware to implement Psr\\Http\\Server\\RequestHandlerInterface or Psr\\Http\\Server\\MiddlewareInterface , respectively. Alternatively, you can decorate your middleware using one of the decorators provided by laminas-stratigility . Please also refer to laminas-stratigility v3 migration guide if you used any of its features. Removed Route Match Params from Request Previously, for the matched route both the Laminas\\Router\\RouteMatch object as well as individual matched params were added to the PSR-7 request as attributes. This is no longer the case and only the RouteMatch object can be accessed as PSR-7 request attribute: $request-&gt;getAttribute(\\Laminas\\Router\\RouteMatch::class); Consider the following route definition: /show-album/:album_id Previously, all matched parameters (in this case album_id ) were available directly in the $request as an attribute: $albumId = $request-&gt;getAttribute('album_id') . Now, this is no longer the case. To get the album_id param you have to fetch it from the RouteMatch object: /** @var \\Laminas\\Router\\RouteMatch $routeMatch */ $routeMatch = $request-&gt;getAttribute(\\Laminas\\Router\\RouteMatch::class); $albumId = $routeMatch-&gt;getParam('album_id');","title":"Migration from Version 1"},{"location":"v2/migration/#migration-from-version-1","text":"This document details changes made from version 1 of this package or from its implementation in laminas-mvc . If installed, it overrides the default behavior in laminas-mvc.","title":"Migration from Version 1"},{"location":"v2/migration/#controller-route-array-key","text":"In addition to providing a 'middleware' array key in the route defaults definition, the value of the 'controller' array key has to be explicitly set to Laminas\\Mvc\\Middleware\\PipeSpec::class : /* ... */ 'some-route' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/some-route', 'defaults' =&gt; [ 'controller' =&gt; \\Laminas\\Mvc\\Middleware\\PipeSpec::class, 'middleware' =&gt; SomeRequestHandler::class, ], ], ],","title":"'controller' Route Array Key"},{"location":"v2/migration/#pipespec-instance-in-middleware-definition","text":"If you used to pass an array of middleware to the middleware array key to create a middleware pipe, it has to be rewritten to an instance of the PipeSpec object. Before: /* ... */ 'some-route' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/some-route', 'defaults' =&gt; [ 'middleware' =&gt; [ SomeMiddleware::class, SomeRequestHandler::class, ], ], ], ], After: /* ... */ 'some-route' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/some-route', 'defaults' =&gt; [ 'controller' =&gt; \\Laminas\\Mvc\\Middleware\\PipeSpec::class, 'middleware' =&gt; new \\Laminas\\Mvc\\Middleware\\PipeSpec( SomeMiddleware::class, SomeRequestHandler::class ), ], ], ],","title":"PipeSpec Instance in middleware Definition"},{"location":"v2/migration/#psr-15-middleware","text":"This package now supports only PSR-15 interfaces. Support of http-interop/http-middleware and callable middleware has been dropped. A Closure can still be used and its signature must match the signature of PSR-15 middleware: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; static function (ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface You have to rewrite all your existing handlers and middleware to implement Psr\\Http\\Server\\RequestHandlerInterface or Psr\\Http\\Server\\MiddlewareInterface , respectively. Alternatively, you can decorate your middleware using one of the decorators provided by laminas-stratigility . Please also refer to laminas-stratigility v3 migration guide if you used any of its features.","title":"PSR-15 Middleware"},{"location":"v2/migration/#removed-route-match-params-from-request","text":"Previously, for the matched route both the Laminas\\Router\\RouteMatch object as well as individual matched params were added to the PSR-7 request as attributes. This is no longer the case and only the RouteMatch object can be accessed as PSR-7 request attribute: $request-&gt;getAttribute(\\Laminas\\Router\\RouteMatch::class); Consider the following route definition: /show-album/:album_id Previously, all matched parameters (in this case album_id ) were available directly in the $request as an attribute: $albumId = $request-&gt;getAttribute('album_id') . Now, this is no longer the case. To get the album_id param you have to fetch it from the RouteMatch object: /** @var \\Laminas\\Router\\RouteMatch $routeMatch */ $routeMatch = $request-&gt;getAttribute(\\Laminas\\Router\\RouteMatch::class); $albumId = $routeMatch-&gt;getParam('album_id');","title":"Removed Route Match Params from Request"},{"location":"v2/quick-start/","text":"Quick Start Mapping Routes to Middleware and Request Handlers The first step is to map a route to PSR-15 middleware or request handler. This looks like any other routing configuration, with small changes: the controller key in the routing options has to be the Laminas\\Mvc\\Middleware\\PipeSpec class literal, and you provide a middleware key. For example, to register an AlbumListHandler located in the module/Application/Handler directory to the routes of your Application module, add the following route to module/Application/config/module.config.php : use Application\\Handler\\AlbumListHandler; use Laminas\\Mvc\\Middleware\\PipeSpec; use Laminas\\Router\\Http\\Literal; return [ 'router' =&gt; [ 'routes' =&gt; [ 'album-list' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/albums', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; AlbumListHandler::class, ], ], ], ], ], ]; Middleware may be provided as instance of a PSR-15 Psr\\Http\\Server\\MiddlewareInterface or Psr\\Http\\Server\\RequestHandlerInterface or as service name strings resolving to such instances. You may also specify an instance of the PipeSpec class which accepts both middleware types above or their service name strings, or a Closure . These will then be piped into a Laminas\\Stratigility\\MiddlewarePipe instance in the order in which they are present in the PipeSpec . See routing middleware for examples. No Action Required Unlike action controllers, middleware typically is single purpose, and, as such, does not require a default action parameter. Middleware Services Middleware are pulled from the application service manager, unlike controllers in a normal laminas-mvc dispatch cycle, which are pulled from a dedicated ControllerManager . Middleware retrieved must be a PSR-15 MiddlewareInterface or RequestHandlerInterface instance. Otherwise, MiddlewareListener will create an error response. Writing Middleware The next step is writing actual middleware to dispatch. PSR-15 defines two different interfaces: MiddlewareInterface vs. RequestHandlerInterface Middleware is code sitting between a request and a response; it typically analyzes the request to aggregate incoming data, delegates it to another layer to process, and then creates and returns a response. A RequestHandler is a class that receives a request and returns a response, without delegating to other layers of the application. This is generally the inner-most layer of your application. For more in-depth documentation visit the documentation for Mezzio and Stratigility or the PSR-15 specification . Request Handlers namespace Application\\Handler; use Application\\Entity\\Album; use Psr\\Http\\Message\\ResponseFactoryInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Message\\StreamFactoryInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class AlbumDetailMiddleware implements RequestHandlerInterface { /** @var ResponseFactoryInterface */ private $responseFactory; /** @var StreamFactoryInterface */ private $streamFactory; public function __construct(ResponseFactoryInterface $responseFactory, StreamFactoryInterface $streamFactory) { $this-&gt;responseFactory = $responseFactory; $this-&gt;streamFactory = $streamFactory; } public function handle(ServerRequestInterface $request): ResponseInterface { /** @var Album $album */ $album = $request-&gt;getAttribute('album'); $body = $this-&gt;streamFactory-&gt;createStream('The name of the album is: ' . $album-&gt;getName()); return $this-&gt;responseFactory-&gt;createResponse()-&gt;withBody($body); } } RequestHandlers resemble a single MVC Controller action, and will be used as the primary application functionality when dispatching a request. Middleware namespace Application\\Middleware; use Application\\Repository\\AlbumRepositoryInterface; use Fig\\Http\\Message\\StatusCodeInterface; use Laminas\\Router\\RouteMatch; use Psr\\Http\\Message\\ResponseFactoryInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class AlbumFromRouteMiddleware implements MiddlewareInterface { /** @var AlbumRepositoryInterface */ private $albumRepository; /** @var ResponseFactoryInterface */ private $responseFactory; public function __construct(AlbumRepositoryInterface $albumRepository, ResponseFactoryInterface $responseFactory) { $this-&gt;albumRepository = $albumRepository; $this-&gt;responseFactory = $responseFactory; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface { /** @var RouteMatch $routeMatch */ $routeMatch = $request-&gt;getAttribute(RouteMatch::class); $albumId = $routeMatch-&gt;getParam('album_id'); $album = $this-&gt;albumRepository-&gt;findById($albumId); // if no album was found, we short-circuit the pipe and return a 404 error: if ($album === null) { return $this-&gt;responseFactory-&gt;createResponse( StatusCodeInterface::STATUS_NOT_FOUND, sprintf('Album with ID %s not found!', $albumId) ); } // ...otherwise we populate the request with the album and call the RequestHandler $request = $request-&gt;withAttribute('album', $album); return $handler-&gt;handle($request); } } Middleware can return a direct response, in effect short-circuiting the middleware pipe, or pass request further while having a chance to act on passed request or returned response. Middleware in laminas-mvc is similar to routed middleware in Mezzio. laminas-mvc does not have a global middleware pipe, so middleware can not be piped in front of MVC controllers. Middleware Return Values As middleware returns a PSR-7 response ( Psr\\Http\\Message\\ResponseInterface ) it is converted back to a laminas-http response and returned by the MiddlewareListener , causing the application to short-circuit and return the response immediately.","title":"Quick Start"},{"location":"v2/quick-start/#quick-start","text":"","title":"Quick Start"},{"location":"v2/quick-start/#mapping-routes-to-middleware-and-request-handlers","text":"The first step is to map a route to PSR-15 middleware or request handler. This looks like any other routing configuration, with small changes: the controller key in the routing options has to be the Laminas\\Mvc\\Middleware\\PipeSpec class literal, and you provide a middleware key. For example, to register an AlbumListHandler located in the module/Application/Handler directory to the routes of your Application module, add the following route to module/Application/config/module.config.php : use Application\\Handler\\AlbumListHandler; use Laminas\\Mvc\\Middleware\\PipeSpec; use Laminas\\Router\\Http\\Literal; return [ 'router' =&gt; [ 'routes' =&gt; [ 'album-list' =&gt; [ 'type' =&gt; Literal::class, 'options' =&gt; [ 'route' =&gt; '/albums', 'defaults' =&gt; [ 'controller' =&gt; PipeSpec::class, 'middleware' =&gt; AlbumListHandler::class, ], ], ], ], ], ]; Middleware may be provided as instance of a PSR-15 Psr\\Http\\Server\\MiddlewareInterface or Psr\\Http\\Server\\RequestHandlerInterface or as service name strings resolving to such instances. You may also specify an instance of the PipeSpec class which accepts both middleware types above or their service name strings, or a Closure . These will then be piped into a Laminas\\Stratigility\\MiddlewarePipe instance in the order in which they are present in the PipeSpec . See routing middleware for examples.","title":"Mapping Routes to Middleware and Request Handlers"},{"location":"v2/quick-start/#middleware-services","text":"Middleware are pulled from the application service manager, unlike controllers in a normal laminas-mvc dispatch cycle, which are pulled from a dedicated ControllerManager . Middleware retrieved must be a PSR-15 MiddlewareInterface or RequestHandlerInterface instance. Otherwise, MiddlewareListener will create an error response.","title":"Middleware Services"},{"location":"v2/quick-start/#writing-middleware","text":"The next step is writing actual middleware to dispatch. PSR-15 defines two different interfaces:","title":"Writing Middleware"},{"location":"v2/quick-start/#middleware-return-values","text":"As middleware returns a PSR-7 response ( Psr\\Http\\Message\\ResponseInterface ) it is converted back to a laminas-http response and returned by the MiddlewareListener , causing the application to short-circuit and return the response immediately.","title":"Middleware Return Values"}]}